import React, {useState} from "react"
import 'antd/dist/antd.css'
import '../style.css'
import {Card, Col, Row, Tree, Typography} from 'antd';

const {Paragraph} = Typography;

const List = () => {

    const [reason, setReason] = useState(' '); //漏洞缘由
    const [detect, setDetect] = useState(' ');//检测方式
    const [text, setText] = useState(' ');//参考文献

    const treeData = [
        {
            title: '语言指令不确定性',
            key: '0-0',
            children: [
                {
                    title: '随机数生成',
                    key: '0-0-0',
                },
                {
                    title: '具体的对象地址',
                    key: '0-0-1',
                },
                {
                    title: '系统时间戳',
                    key: '0-0-2',
                },
                {
                    title: '全局变量',
                    key: '0-0-3',
                },
                {
                    title: '程序并发性',
                    key: '0-0-4',
                },
                {
                    title: '映射结构迭代',
                    key: '0-0-5',
                },
                {
                    title: '字段声明',
                    key: '0-0-6',
                },
            ],
        },
        {
            title: '外部访问不确定性',
            key: '0-1',
            children: [
                {
                    title: '外部文件访问',
                    key: '0-1-0',
                },
                {
                    title: '外部库调用',
                    key: '0-1-1',
                },
                {
                    title: 'Web服务',
                    key: '0-1-2',
                },
                {
                    title: '系统命令执行',
                    key: '0-1-3',
                },
            ],
        },
        {
            title: 'HF平台',
            key: '0-2',
            children: [
                {
                    title: '范围查询风险',
                    key: '0-2-0',
                },
                {
                    title: '写后读',
                    key: '0-2-1',
                },
                {
                    title: '链码沙箱',
                    key: '0-2-2',
                },
                {
                    title: '读写冲突',
                    key: '0-2-3',
                },
                {
                    title: '交易顺序依赖',
                    key: '0-2-4',
                },
                {
                    title: '安全单点故障',
                    key: '0-2-5',
                },
                {
                    title: '日志注入',
                    key: '0-2-6',
                },
            ],
        },
        {
            title: '常见实践',
            key: '0-3',
            children: [
                {
                    title: '未处理的错误',
                    key: '0-3-0',
                },
                {
                    title: '未检查的输入参数',
                    key: '0-3-1',
                },
                {
                    title: '无限循环',
                    key: '0-3-3',
                },
                {
                    title: '未初始化存储指针',
                    key: '0-3-4',
                },
                {
                    title: '写入到任意的存储位置',
                    key: '0-3-5',
                },
                {
                    title: '使用继承的函数和变量',
                    key: '0-3-6',
                },
                {
                    title: '使用弃用函数',
                    key: '0-3-7',
                },
                {
                    title: '使用内置函数',
                    key: '0-3-8',
                },
                {
                    title: '注释标题不足以检查实现和使用情况',
                    key: '0-3-9',
                },
            ],
        },
        {
            title: '隐私数据安全',
            key: '0-4',
            children: [
                {
                    title: '跨通道链码调用',
                    key: '0-4-0',
                },
                {
                    title: '未加密的敏感数据',
                    key: '0-4-1',
                },
                {
                    title: '未使用的隐私数据机制',
                    key: '0-4-2',
                },
            ],
        },
    ];
    const VnrNote = {
        '0-0': '链码是在分布式和独立的对等点中执行的，因此链码业务逻辑的确定是一个主要的关注点。一些用于智能合约的DSLs，比如 Solidity，没有与随机数相关的指令。不同于Solidity，链码采用通用编程语言编写，而通用编程语言通常都有与随机数相关的指令。因此链码可能会错误地使用编程语言的随机数相关指令而产生不确定性，从而导致来自不同节点的认可结果不一致。这违反了 Hyperledger Fabric 的共识规则，导致交易在交易背书阶段失败。因此，有必要在链码中找到非确定性指令。',
        '0-0-0': '随机数属性是典型的非确定性代码之一。在背书阶段，背书节点在不同的环境中独立模拟执行链码。很难确保每个节点在生成随机数时具有相同的结果。即使用伪随机数等可以预测的数据产生方式替代真正的随机数，也有着相应的风险。一个安全的随机数生成器(RNG)应该是不可预测的，而调用智能合约的结果必须是确定性的。这些相互冲突的属性使得在智能合约中实现安全的RNG成为一个具有挑战性的问题。为了防止不确定性，RNG的结果必须在所有背书节点上都可以预测，例如通过使用伪随机数生成器(PRNG)。然而，这使得该合约很容易受到攻击。PRNG通过遵循确定性算法生成数字序列：给定相同的输入或种子，PRNG输出的序列在每次运行时都是相同的。由于所有对等点都需要访问相同的种子，因此它必须在区块链上可访问。那么，潜在的恶意攻击者也可以使用它。如果攻击者知道PRNG使用的种子，就可以预测结果并利用合约。',
        '0-0-1': '开发人员可以通过指针来处理变量的值。指针是内存的地址，地址取决于环境。因此，对象地址具体化的使用可能导致非决定论。Go语言限制了整型(int)转化为*int型，减少了具体化地址的风险。',
        '0-0-2': '与随机数生成漏洞相同一样，每个背书节点中调用时间戳函数的时间不尽相同，因此很难保证不同背书节点产生一致的交易结果。',
        '0-0-3': '全局变量可以从任何函数中访问，是非确定性的常见来源。由于每个节点背书策略的不同，不是每个节点都模拟相同的事务，因此这可能使得每个节点的全局变量的值不同，从而导致链码的非确定性。另外，全局变量仅对单个节点是全局的，如果这样的节点出现故障，全局状态变量可能不再在所有结点上保持一致，因此将全局变量放入账本会导致背书结果不一致。不仅在链码开发中，而且在一般开发中，开发人员都需要考虑全局变量。',
        '0-0-4': 'Go使用 goroutine 和 channel对程序的并发性提供了丰富的支持。如果并发程序没有得到适当的处理，就很容易出现竞争条件问题，使得程序链码的执行顺序无法确定。例如，多个交易在高负载下同时执行，键版本可能发生更改，从而可能导致键冲突和双重支付。',
        '0-0-5': '映射结构迭代可能导致不同的键值对序列。如果链码中使用了映射结构，那么不同节点的链码将获取不一致的键值对序列，导致背书失败。由于 Go 的规范，当开发人员使用带有映射结构的迭代时，键值对的顺序并不唯一。因此，映射结构迭代的使用可能导致非确定性。不同于随机数生成和时间戳，这种行为是Go的隐藏实现细节。了解Go规范或实现的开发人员可以避免引入风险，但其他人可能会引入风险。',
        '0-0-6': '当开发人员在链码中实现chaincode结构体时，需要实现Init方法和Invoke方法来满足 chaincode 接口。当这些方法作为结构的方法实现时，开发人员可以定义结构的字段。该字段可以在方法中访问，也可以与程序中的全局状态一起使用。但是，由于每个peer节点并不执行每个事务，因此这些字段将会和全局变量一样，在不同节点的字段声明无法保持相同的值。',
        '0-1': '同语言指令不确定性类似，外部访问不确定性也与非确定性有关，但是主要强调产生不确定性的原因来自于智能合约的外部访问。非确定性外部调用可能在不同的节点上具有不同的执行逻辑或不确定的数据源，因此不能保证运行结果是一致的。当遇到非确定性外部调用时，开发人员需要清楚地了解获得了什么结果。',
        '0-1-0': '与系统命令执行类似，开发人员还要考虑链码在每个独立的环境中访问外部文件时会发生什么。外部文件访问不能保证在不同的背书节点之间观察到同样的命令结果。',
        '0-1-1': '开发者应用第三方库来减少开发软件的工作量。开发人员还需要注意库的行为，并了解库中发生了什么，第三方库的潜在缺陷是难以控制的。',
        '0-1-2': '在智能合约的背景下，当一个商业逻辑需要来自区块链外部的信息时，开发者需要访问一个叫做“oracle”的实体，这个实体为一个智能合同提供区块链外部的数据。如果服务返回不同的结果给每个peer节点，它会导致分类账的不一致。',
        '0-1-3': 'Go 可以通过os/exec包执行外部命令。这个特性很有用，但是开发人员在链码开发环境中使用它时需要非常小心。os/exec包不能保证在不同的背书节点中观察到同样的命令结果。另外，外部命令是否存在异常情况也未可知，为保证智能合约正常运行，不建议使用外部命令。',
        '0-2': 'HF平台这类风险取决于HF的规范或实现。该类漏洞主要存在于HF状态数据库操作、交易机制等HF平台运作过程中。随着HF的改进，这些风险将得到修复。',
        '0-2-0': 'HF提供了一些范围内的查询方法来访问状态数据库，比如函数 GetQueryResult、 getprivateddataqueryresult和 getthistoryforkey。这些方法在背书阶段执行，但不会在验证阶段重新执行。这意味着不会检测到幻象读操作。幻影可能会读取其他事务添加或删除的数据，并更改进程的结果。因此，这些方法不能用于修改链码中的分类账，只能用于查询分类账的交易。',
        '0-2-1': '在HF中，将区块链的交易数据写入分类账的操作在交易完成和验证后执行。要使写入语句生效，必须首先提交事务。因此，链码中对同一进程的变量执行的写入操作并未实际写入分类账中，若同一进程中数据被篡改后被再次读取，分类账中不存在该变量值或是存在该变量旧值，存在潜在的数据不一致的风险。因此在链码中不建议对写入的数据进行读取。',
        '0-2-2': 'HF智能合约在封闭的Docker容器中执行，并具有Docker容器的绝对权限。然而，封闭式并非是安全的，Docker可能被恶意攻击所利用。',
        '0-2-3': '在交易的背书过程中，会生成一个读写集。读取集包含交易从状态数据库中读取的唯一键及其提交版本的列表。写入集包含交易将写入状态数据库的唯一键及其新值的列表。同时，写入集中键的版本也将被更新。对于一笔交易，当交易结果实际保存在账本中时，背书阶段与提交阶段之间存在一个时间间隔。MVCC检查读取集中每个键的版本，在背书阶段和提交阶段之间是否一致。在此时间间隔内，如果其他交易已经更新了读取集中键的版本，则该交易将无法通过MVCC的验证。因此，当多个交易同时提交到HF网络时，读写冲突的风险可能会使一些交易无效，使交易的最终结果具有不确定性。',
        '0-2-4': '在交易提交后，区块链会对交易信息进行处理。有效的交易处理可以更改HF区块链的账本状态。但是，如果用户同时或在短时间间隔内向HF网络提交多个交易，则交易的最终提交顺序是不确定的。因此，区块链的账本状态也是不一致的。混乱的交易顺序也会影响各个交易的执行。',
        '0-2-5': '1.单排序者：如果系统使用单个排序者并妥协，攻击者能够驳回交易或认可恶意交易。\n' +
            '2.单root CA：如果TLS和MSP证书使用相同的CA，在这种情况下，如果根CA受到损害，那么攻击者可以同时生成TLS和MSP证书，并像一个新节点一样满足通道中的所有安全要求。\n',
        '0-3': '在开发过程中，开发人员应该考虑一些实践。',
        '0-3-0': '在 Go 中，开发人员可以通过将索引或值赋值为“_”来跳过索引或值。即使该值是一种错误类型，开发人员也可以跳过它。但是这样容易忽略错误的发生，错误得不到合适的处理将会导致不可想象的问题。',
        '0-3-1': '这在任何编程语言中都是常见的情况。如果没有检查输入参数，并且程序允许访问不存在的元素，则会发生错误。',
        '0-2-6': '链码日志消息的任何损坏都可能避免区块链被自动执行，并允许攻击者查看已处理的日志。因此，攻击者可以通过注入恶意日志来使系统出错，从而达到查看所有日志的目的。',
        '0-3-3': '智能合约的执行环境的支持，如solidity智能合约的执行涉及到gas的消耗，智能合约使用的内存地址等。如果智能合约中存在无限循环，就会导致过度的gas消耗，内存地址数量显著增加等。这样不仅智能合约无法正常工作，也会使得运行智能合约的成本变得高昂。',
        '0-3-4': '默认情况下，本地结构体、数组和映射链接到存储零地址。使用这些没有初始化的对象将导致覆盖零地址中的任何内容。',
        '0-3-5': '智能合约可以存储一些数据，而错误的变量分配可能会破坏它。如果数组索引超出范围，则将抛出异常，并恢复智能合约。',
        '0-3-6': '链码可以使用面向对象的范式在智能合约语言中使用继承。Go通过结构体的方式实现多重继承。如果几个超级类具有相同名称的方法或变量，则它们在子类中的行为取决于继承顺序。它可能会阴影以前定义的值或函数，并导致不希望的结果。',
        '0-3-7': '编程语言在不断的更新迭代过程中，在这个过程中会出现大量的弃用函数。函数的弃用在一定程度上说明了这些函数的不完善，所以不建议在链码使用这些函数，以保证链码的正常运行。',
        '0-3-8': '开发人员应该注意使用内置的函数及其行为。例如有人想使用断言来检查程序不变变量。SOLIDITY assert()函数将用于此目的。',
        '0-3-9': '希望每个函数与其调用者之间的合约被记录下来，这减少了必须阅读和理解的代码量。虽然这不是一个恶意者可利用的漏洞，但如果它使代码审查过程的效率降低，这是一个安全风险。比如有些函数没有接口文档。',
        '0-4': '隐私数据安全风险是指在模拟链码时，由于操作权限问题导致交易失败的风险，或由于缺乏安全措施导致敏感数据泄漏的风险。',
        '0-4-0': 'HF提供跨通道链码调用功能。链码可以调用同一通道上的其他链码来访问或修改状态数据库，但不能调用不同通道上的其他链码来创建新事务，只能获得 chaincode 函数返回的内容。因此，在使用跨通道调用函数时，开发人员应该避免在另一个通道上调用链码来创建新事务。',
        '0-4-1': '如果链码中存在未加密的敏感数据，敏感交易数据的明文将存储在分类账中，这可能导致交易数据泄露。',
        '0-4-2': '为了保护敏感数据，HF还提供了一个私有数据机制，以加强交易数据的安全性。如果链码中存在未使用的隐私数据机制，交易数据的安全性可能会被削弱。',
    }
    const detects = {
        '0': '静态检测',
        '1': '动态检测',
        '2': '无需检测，链码编译阶段可检测出该漏洞类型',
        '3': '暂未覆盖该类型'
    }
    const contents = {
        '0-0': '{-}{-}{4}',
        '0-0-0': '{0}{错误使用[库文件]，随机数生成漏洞}{4}',
        '0-0-1': '{2}{-}{4}',
        '0-0-2': '{0}{错误使用[库文件]，系统时间戳漏洞}{4}',
        '0-0-3': '{0}{存在全局变量漏洞：[变量名称]}{4}',
        '0-0-4': '{0}{不建议使用goroutine/channel，易造成程序并发性漏洞}{4}',
        '0-0-5': '{0}{存在映射结构迭代：[变量名称]}{4}',
        '0-0-6': '{0}{结构体中不建议声明变量（字段声明漏洞）[字段名称]}{4}',
        '0-1': '{-}{-}{4}',
        '0-1-0': '{0}{错误使用[库文件]，外部文件访问}{4}',
        '0-1-1': '{0}{调用了外部库[库文件],外部库调用漏洞}{4}',
        '0-1-2': '{0}{错误使用[库文件]，Web服务漏洞}{4}',
        '0-1-3': '{0}{错误使用[库文件]，系统命令执行漏洞}{4}',
        '0-2': '{-}{-}{4}',
        '0-2-0': '{0}{存在范围查询风险：[函数名称]}{4}',
        '0-2-1': '{0}{存在写后读漏洞:[key]}{4}',
        '0-2-2': '{3}{-}{4}',
        '0-2-3': '{3}{-}{4}',
        '0-2-4': '{3}{-}{4}',
        '0-2-5': '{3}{-}{4}',
        '0-3': '{-}{-}{4}',
        '0-3-0': '{0}{未处理的错误：[未处理错误的源码]}{4}',
        '0-3-1': '{1}{[函数名称]函数未检查输入参数}{4}',
        '0-2-6': '{3}{-}{4}',
        '0-3-3': '{1}{存在无线循环}{4}',
        '0-3-4': '{0}{未初始化存储指针：[变量名称]未初始化}{4}',
        '0-3-5': '{2}{-}{4}',
        '0-3-6': '{0}{使用继承的函数和变量漏洞:[变量名称]结构体多重继承[超级类名称]和[超级类名称],且超级类具有相同名称的方法或变量[变量名称集合]}{4}',
        '0-3-7': '{2}{-}{4}',
        '0-3-8': '{0}{建议不使用内置函数[函数名称]}{4}',
        '0-3-9': '{1}{注释标题不足以检查实现和使用情况:[函数名称]函数未添加注释说明}{4}',
        '0-4': '{-}{-}{4}',
        '0-4-0': '{0}{使用InvokeChaincode调用[通道名称]通道链码,可能存在隐私数据安全风险}{4}',
        '0-4-1': '{0}{没有使用crypto包加密}{4}',
        '0-4-2': '{0}{未使用的隐私数据机制:建议使用EMP-toolkit对上链数据进行加密}{4}',
    }

    const onSelect = (selectedKeys: React.Key[], info: any) => {
        let cnt = contents[selectedKeys[0]]
        console.log(cnt)
        let datas = cnt.split(/[{}]/)
        console.log(datas)
        console.log(selectedKeys)
        setReason(VnrNote[selectedKeys[0]])
        setDetect(detects[datas[1]])
        setText(datas[3])
    };
    return (
        <>
            <div className="site-card-border-less-wrapper">
                <Row gutter={3}>
                    <Col span={6}>
                        <Card bordered={false} style={{height: 550}}>
                            <Tree
                                showLine={{showLeafIcon: false}}
                                showIcon={true}
                                onSelect={onSelect}
                                defaultExpandAll={false}
                                treeData={treeData}
                                height={500}
                            />
                        </Card>
                    </Col>
                    <Col span={18}>
                        <Card bordered={false} style={{height: 550}}>
                            <Paragraph>
                                <blockquote><h3>漏洞缘由</h3></blockquote>
                                <pre>{reason}</pre>
                                <blockquote><h3>检测方式</h3></blockquote>
                                <pre>{detect}</pre>
                                <blockquote><h3>报错格式</h3></blockquote>
                                <pre>{text}</pre>
                            </Paragraph>
                        </Card>
                    </Col>
                </Row>
            </div>
        </>
    );
};

export default List
